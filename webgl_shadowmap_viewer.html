<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - ShadowMapViewer example </title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<script src="https://cdn.jsdelivr.net/npm/tweakpane@1.5.7/dist/tweakpane.min.js"></script>
	</head>
	<body>
		<div id="info">
		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - ShadowMapViewer example by <a href="https://github.com/arya-s">arya-s</a>
		</div>

<script id="vertex-shader" type="x-shader/x-vertex">
    uniform float time;


    void main()
    {
    vec3 posChanged = position;
    posChanged.x = posChanged.x*(abs(sin(time*1.0)));
    posChanged.y = posChanged.y*(abs(cos(time*1.0)));
    posChanged.z = posChanged.z*(abs(sin(time*1.0)));
    //gl_Position = projectionMatrix * modelViewMatrix * vec4(position*(abs(sin(time)/2.0)+0.5),1.0);
    gl_Position = projectionMatrix * modelViewMatrix * vec4(posChanged,1.0);
    }

</script>
<script id="fragment-shader-1" type="x-shader/x-fragment">
    precision highp float;
    uniform float time;
    uniform float alpha;
    uniform vec2 resolution;
    varying vec2 vUv;

    void main2(void)
    {
    vec2 position = vUv;
    float red = 1.0;
    float green = 0.25 + sin(time) * 0.25;
    float blue = 0.0;
    vec3 rgb = vec3(red, green, blue);
    vec4 color = vec4(rgb, alpha);
    gl_FragColor = color;
    }

    #define PI 3.14159
    #define TWO_PI (PI*2.0)
    #define N 68.5

    void main(void)
    {
    vec2 center = (gl_FragCoord.xy);
    center.x=-10.12*sin(time/200.0);
    center.y=-10.12*cos(time/200.0);

    vec2 v = (gl_FragCoord.xy - resolution/20.0) / min(resolution.y,resolution.x) * 15.0;
    v.x=v.x-10.0;
    v.y=v.y-200.0;
    float col = 0.0;

    for(float i = 0.0; i < N; i++)
    {
    float a = i * (TWO_PI/N) * 61.95;
    col += cos(TWO_PI*(v.y * cos(a) + v.x * sin(a) + sin(time*0.004)*100.0 ));
    }

    col /= 5.0;

    gl_FragColor = vec4(col*1.0, -col*1.0,-col*4.0, 1.0);
    }


</script>

<script id="fragment-shader-2" type="x-shader/x-fragment">
    // from http://glsl.heroku.com/e#7906.0


    uniform float time;
    uniform vec2 resolution;

    // 2013-03-30 by @hintz

    #define CGFloat float
    #define M_PI 3.14159265359

    vec3 hsvtorgb(float h, float s, float v)
    {
    float c = v * s;
    h = mod((h * 6.0), 6.0);
    float x = c * (1.0 - abs(mod(h, 2.0) - 1.0));
    vec3 color;

    if (0.0 <= h && h < 1.0)
    {
    color = vec3(c, x, 0.0);
    }
    else if (1.0 <= h && h < 2.0)
    {
    color = vec3(x, c, 0.0);
    }
    else if (2.0 <= h && h < 3.0)
    {
    color = vec3(0.0, c, x);
    }
    else if (3.0 <= h && h < 4.0)
    {
    color = vec3(0.0, x, c);
    }
    else if (4.0 <= h && h < 5.0)
    {
    color = vec3(x, 0.0, c);
    }
    else if (5.0 <= h && h < 6.0)
    {
    color = vec3(c, 0.0, x);
    }
    else
    {
    color = vec3(0.0);
    }

    color += v - c;

    return color;
    }

    void main(void)
    {

    vec2 position = (gl_FragCoord.xy - 0.5 * resolution) / resolution.y;
    float x = position.x;
    float y = position.y;

    CGFloat a = atan(x, y);

    CGFloat d = sqrt(x*x+y*y);
    CGFloat d0 = 0.5*(sin(d-time)+1.5)*d;
    CGFloat d1 = 5.0;

    CGFloat u = mod(a*d1+sin(d*10.0+time), M_PI*2.0)/M_PI*0.5 - 0.5;
    CGFloat v = mod(pow(d0*4.0, 0.75),1.0) - 0.5;

    CGFloat dd = sqrt(u*u+v*v);

    CGFloat aa = atan(u, v);

    CGFloat uu = mod(aa*3.0+3.0*cos(dd*30.0-time), M_PI*2.0)/M_PI*0.5 - 0.5;
    // CGFloat vv = mod(dd*4.0,1.0) - 0.5;

    CGFloat d2 = sqrt(uu*uu+v*v)*1.5;

    gl_FragColor = vec4( hsvtorgb(dd+time*0.5/d1, sin(dd*time), d2), 1.0 );
    }

</script>

<script id="fragment-shader-3" type="x-shader/x-fragment">
    uniform vec2 resolution;
    uniform float time;

    vec2 rand(vec2 pos)
    {
    return fract( 0.00005 * (pow(pos+2.0, pos.yx + 1.0) * 22222.0));
    }
    vec2 rand2(vec2 pos)
    {
    return rand(rand(pos));
    }

    float softnoise(vec2 pos, float scale)
    {
    vec2 smplpos = pos * scale;
    float c0 = rand2((floor(smplpos) + vec2(0.0, 0.0)) / scale).x;
    float c1 = rand2((floor(smplpos) + vec2(1.0, 0.0)) / scale).x;
    float c2 = rand2((floor(smplpos) + vec2(0.0, 1.0)) / scale).x;
    float c3 = rand2((floor(smplpos) + vec2(1.0, 1.0)) / scale).x;

    vec2 a = fract(smplpos);
    return mix(
    mix(c0, c1, smoothstep(0.0, 1.0, a.x)),
    mix(c2, c3, smoothstep(0.0, 1.0, a.x)),
    smoothstep(0.0, 1.0, a.y));
    }

    void main(void)
    {
    vec2 pos = gl_FragCoord.xy / resolution.y;
    pos.x += time * 0.1;
    float color = 0.0;
    float s = 1.0;
    for(int i = 0; i < 8; i++)
    {
    color += softnoise(pos+vec2(i)*0.02, s * 4.0) / s / 2.0;
    s *= 2.0;
    }
    gl_FragColor = vec4(color);
    }

</script>

<script id="fragment-shader-4" type="x-shader/x-fragment">


    uniform float time;
    uniform vec2 resolution;

    vec2 rand(vec2 pos)
    {
    return
    fract(
    (
    pow(
    pos+2.0,
    pos.yx+2.0
    )*555555.0
    )
    );
    }

    vec2 rand2(vec2 pos)
    {
    return rand(rand(pos));
    }

    float softnoise(vec2 pos, float scale) {
    vec2 smplpos = pos * scale;
    float c0 = rand2((floor(smplpos) + vec2(0.0, 0.0)) / scale).x;
    float c1 = rand2((floor(smplpos) + vec2(1.0, 0.0)) / scale).x;
    float c2 = rand2((floor(smplpos) + vec2(0.0, 1.0)) / scale).x;
    float c3 = rand2((floor(smplpos) + vec2(1.0, 1.0)) / scale).x;

    vec2 a = fract(smplpos);
    return mix(mix(c0, c1, smoothstep(0.0, 1.0, a.x)),
    mix(c2, c3, smoothstep(0.0, 1.0, a.x)),
    smoothstep(0.0, 1.0, a.x));
    }

    void main( void ) {
    vec2 pos = gl_FragCoord.xy / resolution.y - time * 0.4;

    float color = 0.0;
    float s = 1.0;
    for (int i = 0; i < 6; ++i) {
    color += softnoise(pos + vec2(0.01 * float(i)), s * 4.0) / s / 2.0;
    s *= 2.0;
    }
    gl_FragColor = vec4(color,mix(color,cos(color),sin(color)),color,1);
    }

</script>

<script id="fragment-shader-5" type="x-shader/x-fragment">

    uniform float time;
    uniform vec2 resolution;

    // tie nd die by Snoep Games.

    void main( void ) {

    vec3 color = vec3(1.0, 0., 0.);
    vec2 pos = (( 1.4 * gl_FragCoord.xy - resolution.xy) / resolution.xx)*1.5;
    float r=sqrt(pos.x*pos.x+pos.y*pos.y)/15.0;
    float size1=2.0*cos(time/60.0);
    float size2=2.5*sin(time/12.1);

    float rot1=13.00; //82.0+16.0*sin(time/4.0);
    float rot2=-50.00; //82.0+16.0*sin(time/8.0);
    float t=sin(time);
    float a = (60.0)*sin(rot1*atan(pos.x-size1*pos.y/r,pos.y+size1*pos.x/r)+time);
    a += 200.0*acos(pos.x*2.0+cos(time/2.0))+asin(pos.y*5.0+sin(time/2.0));
    a=a*(r/50.0);
    a=200.0*sin(a*5.0)*(r/30.0);
    if(a>5.0) a=a/200.0;
    if(a<0.5) a=a*22.5;
    gl_FragColor = vec4( cos(a/20.0),a*cos(a/200.0),sin(a/8.0), 1.0 );
    }


</script>

<script id="fragment-shader-6" type="x-shader/x-fragment">


    uniform float time;
    uniform vec2 resolution;


    void main( void )
    {

    vec2 uPos = ( gl_FragCoord.xy / resolution.xy );//normalize wrt y axis
    //suPos -= vec2((resolution.x/resolution.y)/2.0, 0.0);//shift origin to center

    uPos.x -= 1.0;
    uPos.y -= 0.5;

    vec3 color = vec3(0.0);
    float vertColor = 2.0;
    for( float i = 0.0; i < 15.0; ++i )
    {
    float t = time * (0.9);

    uPos.y += sin( uPos.x*i + t+i/2.0 ) * 0.1;
    float fTemp = abs(1.0 / uPos.y / 100.0);
    vertColor += fTemp;
    color += vec3( fTemp*(10.0-i)/10.0, fTemp*i/10.0, pow(fTemp,1.5)*1.5 );
    }

    vec4 color_final = vec4(color, 1.0);
    gl_FragColor = color_final;
    }

</script>



<script type="module">


function createMaterial(vertexShader, fragmentShader) {
            var vertShader = document.getElementById(vertexShader).innerHTML;
            var fragShader = document.getElementById(fragmentShader).innerHTML;

            var uniforms = {
                time: {type: 'f', value: 0.2},
                scale: {type: 'f', value: 0.2},
                alpha: {type: 'f', value: 0.6},
                resolution: {type: "v2", value: new THREE.Vector2()}
            };

            uniforms.resolution.value.x = window.innerWidth;
            uniforms.resolution.value.y = window.innerHeight;

            var meshMaterial = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vertShader,
                fragmentShader: fragShader,
                transparent: true

            });


            return meshMaterial;
        }



let text1 = 'textures/01/alphaMap.jpg';

const PARAMS = {
  theme: '',
};

const pane = new Tweakpane();
pane.addInput(PARAMS, 'theme', {
  options: {
    none: 'textures/01/alphaMap.jpg',
    dark: "textures/01/FloorsCheckerboard_S_Diffuse.jpg",
    light: "textures/01/758px-Canestra_di_frutta_(Caravaggio).jpg",
  },
}).on('change', (v) => {
	console.log(v);
	//init();
		//animate();
		let textureLoader = new THREE.TextureLoader();
		text1 = textureLoader.load(String(v));
				material2.map = text1;
				material2.needsUpdate = true;

                spotLight.angle = Math.PI/  Math.floor(Math.random() * Math.floor(16));

});


			import * as THREE from '../build/three.module.js';

			import Stats from './jsm/libs/stats.module.js';

			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { ShadowMapViewer } from './jsm/utils/ShadowMapViewer.js';

			let camera, scene, renderer, clock, stats;
			let dirLight, spotLight;
			let torusKnot, cube;
			let dirLightShadowMapViewer, spotLightShadowMapViewer;

			// wall
			let material2;

			init();
			animate();


			function init() {

				initScene();
				initShadowMapViewers();
				initMisc();

				document.body.appendChild( renderer.domElement );
				window.addEventListener( 'resize', onWindowResize, false );

			}

			function initScene() {

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 0, 15, 35 );

				scene = new THREE.Scene();

				// Lights

				//scene.add( new THREE.AmbientLight( 0x404040 ) );
				scene.add( new THREE.AmbientLight( 0x040705 ) );

				spotLight = new THREE.SpotLight( 0xffffff );
				spotLight.name = 'Spot Light';
				spotLight.angle = Math.PI / 3;
				spotLight.penumbra = 0.3;
				spotLight.position.set( 10, 10, 5 );
				spotLight.castShadow = true;
				spotLight.shadow.camera.near = 8;
				spotLight.shadow.camera.far = 30;
				spotLight.shadow.mapSize.width = 1024;
				spotLight.shadow.mapSize.height = 1024;

				spotLight.needsUpdate = true;
				scene.add( spotLight );

				//scene.add( new THREE.CameraHelper( spotLight.shadow.camera ) );

				//dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
				dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
				dirLight.name = 'Dir. Light';
				dirLight.position.set( 0, 0, 0 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.near = 1;
				dirLight.shadow.camera.far = 10;
				dirLight.shadow.camera.right = 15;
				dirLight.shadow.camera.left = - 15;
				dirLight.shadow.camera.top	= 15;
				dirLight.shadow.camera.bottom = - 15;
				//dirLight.shadow.mapSize.width = 2048;
				dirLight.shadow.mapSize.width = 1024;
				dirLight.shadow.mapSize.height = 1024;

				dirLight.needsUpdate = true;

				//scene.add( dirLight );

				//scene.add( new THREE.CameraHelper( dirLight.shadow.camera ) );

				// Geometry
				let geometry = null;
				let material = null;
				/*
				geometry = new THREE.TorusKnotBufferGeometry( 25, 8, 75, 20 );
				material = new THREE.MeshPhongMaterial( {
					color: 0xff0010,
					shininess: 150,
					specular: 0x222222
				} );
*/
				/*
				torusKnot = new THREE.Mesh( geometry, material );
				torusKnot.scale.multiplyScalar( 1 / 18 );
				torusKnot.position.y = 3;
				torusKnot.castShadow = true;
				torusKnot.receiveShadow = true;
				scene.add( torusKnot );

				geometry = new THREE.BoxBufferGeometry( 3, 3, 3 );
				cube = new THREE.Mesh( geometry, material );
				cube.position.set( 8, 3, 8 );
				cube.castShadow = true;
				cube.receiveShadow = true;
				scene.add( cube );

				*/

				geometry = new THREE.BoxBufferGeometry( 10, 0.15, 10 );
				material = new THREE.MeshPhongMaterial( {
					//color: 0xa0adaf,
					shininess: 150, //150
					specular: 0x111111
				} );
				let textureLoader = new THREE.TextureLoader();
				let texture = textureLoader.load('textures/01/FloorsCheckerboard_S_Diffuse.jpg');
				material.map = texture;

				const ground = new THREE.Mesh( geometry, material );
				ground.scale.multiplyScalar( 3 );
				ground.castShadow = false;
				ground.receiveShadow = true;
				ground.position.y = -7.25;
				scene.add( ground );

				// wall 
			
				let geometry2 = new THREE.BoxGeometry( 30, 15, 1 );
				material2 = new THREE.MeshBasicMaterial( /*{color: 0x11aa90}*/ );
				//texture = textureLoader.load('textures/01/alphaMap.jpg');
				texture = textureLoader.load(text1);
				material2.map = texture;
				material2.needsUpdate = true;

				const cube2 = new THREE.Mesh( geometry2, material2 );
				cube2.position.z = -15;
				//cube2.position.y = 5;
				cube2.position.y = 0;
				scene.add( cube2 );
				
				texture = textureLoader.load('textures/01/758px-Canestra_di_frutta_(Caravaggio).jpg');
				const geometry3 = new THREE.BoxGeometry( -1, 15, 30 );
				const material3 = new THREE.MeshBasicMaterial( /*{color: 0xa0a0ff}*/ );
				material3.map = texture;
				const cube3 = new THREE.Mesh( geometry3, material3 );
				cube3.position.x = -15;
				cube3.position.y = 0;
				scene.add( cube3 );


                /* shader 
        var cubeGeometry = new THREE.BoxGeometry(20, 20, 20);

        var meshMaterial1 = createMaterial("vertex-shader", "fragment-shader-1");
        var meshMaterial2 = createMaterial("vertex-shader", "fragment-shader-2");
        var meshMaterial3 = createMaterial("vertex-shader", "fragment-shader-3");
        var meshMaterial4 = createMaterial("vertex-shader", "fragment-shader-4");
        var meshMaterial5 = createMaterial("vertex-shader", "fragment-shader-5");
        var meshMaterial6 = createMaterial("vertex-shader", "fragment-shader-6");


        var material4 = new THREE.MeshFaceMaterial(
                [meshMaterial1,
                    meshMaterial2,
                    meshMaterial3,
                    meshMaterial4,
                    meshMaterial5,
                    meshMaterial6]);
//        var material = new THREE.MeshFaceMaterial([meshMaterial2, meshMaterial2, meshMaterial1, meshMaterial1, meshMaterial1, meshMaterial1]);

        var cube = new THREE.Mesh(cubeGeometry, material4);


        // add the sphere to the scene
        scene.add(cube);

        // position and point the camera to the center of the scene
        camera.position.x = 30;
        camera.position.y = 30;
        camera.position.z = 30;
        camera.lookAt(new THREE.Vector3(0, 0, 0));

*/

			}

			function initShadowMapViewers() {

				//dirLightShadowMapViewer = new ShadowMapViewer( dirLight );
				//spotLightShadowMapViewer = new ShadowMapViewer( spotLight );
				resizeShadowMapViewers();

			}

			function initMisc() {

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.BasicShadowMap;

				// Mouse control
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 2, 0 );
				controls.update();

				clock = new THREE.Clock();

				stats = new Stats();
				document.body.appendChild( stats.dom );

			}

			function resizeShadowMapViewers() {

				const size = window.innerWidth * 0.15;

				/*
				dirLightShadowMapViewer.position.x = 10;
				dirLightShadowMapViewer.position.y = 10;
				dirLightShadowMapViewer.size.width = size;
				dirLightShadowMapViewer.size.height = size;
				dirLightShadowMapViewer.update(); //Required when setting position or size directly
			

				spotLightShadowMapViewer.size.set( size, size );
				spotLightShadowMapViewer.position.set( size + 20, 10 );
				spotLightShadowMapViewer.update();	//NOT required because .set updates automatically
	*/

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				resizeShadowMapViewers();
				// dirLightShadowMapViewer.updateForWindowResize();
				// spotLightShadowMapViewer.updateForWindowResize();

			}

			function animate() {

				requestAnimationFrame( animate );
				render();

				stats.update();

			}

			function renderScene() {

				renderer.render( scene, camera );

			}

			function renderShadowMapViewers() {

				//dirLightShadowMapViewer.render( renderer );
				//spotLightShadowMapViewer.render( renderer );

			}

			function render() {

				const delta = clock.getDelta();

				renderScene();
				renderShadowMapViewers();

//console.log(delta*250);

	//dirLight.shadow.camera.top	+= 10;

				/*
				torusKnot.rotation.x += 0.25 * delta;
				torusKnot.rotation.y += 2 * delta;
				torusKnot.rotation.z += 1 * delta;

				cube.rotation.x += 0.25 * delta;
				cube.rotation.y += 2 * delta;
				cube.rotation.z += 1 * delta;
*/

			}

		</script>
	</body>
</html>
