<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - ShadowMapViewer example </title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<script src="https://cdn.jsdelivr.net/npm/tweakpane@1.5.7/dist/tweakpane.min.js"></script>
    <script type="text/javascript" src="../otherresources/dat.gui.min.js"></script>

	</head>
	<body>
		<div id="info">
		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - ShadowMapViewer example by <a href="https://github.com/arya-s">arya-s</a>
		</div>

//
//カメラ
//ライト
//質感
//


		<script type="module">

/*
let text1 = 'textures/01/alphaMap.jpg';

const PARAMS = {
  theme: '',
   background: 0x0088ff,
	//background: {r: 255, g: 127, b: 0},
  tint: 0x00ff0044,

};

const pane = new Tweakpane();
pane.addInput(PARAMS, 'theme', {
  options: {
    none: 'textures/01/alphaMap.jpg',
    dark: "textures/01/FloorsCheckerboard_S_Diffuse.jpg",
    light: "textures/01/758px-Canestra_di_frutta_(Caravaggio).jpg",
  },
}).on('change', (v) => {
	console.log(v);
	//init();
		//animate();
		let textureLoader = new THREE.TextureLoader();
		text1 = textureLoader.load(String(v));
				material2.map = text1;
				material2.needsUpdate = true;

				let randnum = Math.floor(Math.random() * Math.floor(10))
				modelApple.position.set(1, randnum, 10)

});

pane.addInput(PARAMS, 'background', {
  input: 'color',
}).on('change', (v) => {
	console.log(JSON.stringify(v));
	//init();
		//animate();
		spotLight.color = JSON.stringify(v);

});

pane.addInput(PARAMS, 'tint', {
  input: 'color.rgba',
}).on('change', (v) => {
	console.log(v);
	//init();
		//animate();
		let textureLoader = new THREE.TextureLoader();
		text1 = textureLoader.load(String(v));
				material2.map = text1;
				material2.needsUpdate = true;

				let randnum = Math.floor(Math.random() * Math.floor(10))
				modelApple.position.set(1, randnum, 10)

});

*/

////////////////////////////////////
// call the render function
var step = 0;

// used to determine the switch point for the light animation
var invert = 1;
var phase = 0;

let cameraFolder
let spotLightFolder
let dirLightFolder
let model1Folder

var controls = new function () {

	// for camera
	this.cam_pos_x = 10;
	this.cam_pos_y = 10;
	this.cam_pos_z = 10;

	// for spotLight
	this.sl_color = '#ffffff';
	this.sl_pos_x = 10;
	this.sl_pos_y = 10;
	this.sl_pos_z = 10;
	this.sl_angle = 3;
	this.sl_intensity = 0.5;
	this.sl_distance = 0;

	// for directionalLight
	this.dl_color = '#ffffff';
	this.dl_pos_x = 10;
	this.dl_pos_y = 10;
	this.dl_pos_z = 10;
	this.dl_angle = 3;
	this.dl_intensity = 0.5;
	this.dl_distance = 0;


	this.rotationSpeed = 0.03;
	this.bouncingSpeed = 0.03;
		//this.ambientColor = ambiColor;
		//this.pointColor = pointColor;
	this.penumbra = 30;
	this.angle = 0.1;
	this.debug = false;
	this.castShadow = true;
	this.target = "Plane";

	// for apple
	this.model1_pos_x = 10;
	this.model1_pos_y = 10;
	this.model1_pos_z = 10;

};

var gui = new dat.GUI();

cameraFolder = gui.addFolder('camera')

cameraFolder.add(controls, 'cam_pos_x', 10, 100).onChange(function (e) {
	let nextValue = parseInt(e)
	camera.position.set( nextValue, controls.cam_pos_y, controls.cam_pos_z );
});

cameraFolder.add(controls, 'cam_pos_y', 10, 100).onChange(function (e) {
	let nextValue = parseInt(e)
	camera.position.set( controls.cam_pos_x, nextValue, controls.cam_pos_z );
});

cameraFolder.add(controls, 'cam_pos_z', 10, 100).onChange(function (e) {
	let nextValue = parseInt(e)
	camera.position.set( controls.cam_pos_x, controls.cam_pos_y, nextValue );
});


spotLightFolder = gui.addFolder('spotLight')

spotLightFolder.addColor(controls, 'sl_color').onChange(function (e) {
		spotLight.color = new THREE.Color(e);
});

spotLightFolder.add(controls, 'sl_pos_x', 10, 100).onChange(function (e) {
	let nextValue = parseInt(e)
	spotLight.position.set( nextValue, controls.sl_pos_y, controls.sl_pos_z );
});

spotLightFolder.add(controls, 'sl_pos_y', 10, 100).onChange(function (e) {
	let nextValue = parseInt(e)
	spotLight.position.set( controls.sl_pos_x, nextValue, controls.sl_pos_z );
});

spotLightFolder.add(controls, 'sl_pos_z', 10, 100).onChange(function (e) {
	let nextValue = parseInt(e)
	spotLight.position.set( controls.sl_pos_x, controls.sl_pos_y, nextValue );
});

spotLightFolder.add(controls, 'sl_angle', 0, 6 ,1).onChange(function (e) {
	let nextValue = parseInt(e)
	spotLight.angle = nextValue;
});

spotLightFolder.add(controls, 'sl_intensity', 0, 5).onChange(function (e) {
	let nextValue = parseInt(e)
	spotLight.intensity = nextValue;
});

gui.add(controls, 'sl_distance', 0, 200).onChange(function (e) {
		let nextValue = parseInt(e)
		spotLight.distance = nextValue;
});


dirLightFolder = gui.addFolder('dirLight')

dirLightFolder.add(controls, 'dl_pos_x', 10, 100).onChange(function (e) {
	let nextValue = parseInt(e)
	dirLight.position.set( nextValue, controls.dl_pos_y, controls.dl_pos_z );
});

dirLightFolder.add(controls, 'dl_pos_y', 10, 100).onChange(function (e) {
	let nextValue = parseInt(e)
	dirLight.position.set( controls.dl_pos_x, nextValue, controls.dl_pos_z );
});

dirLightFolder.add(controls, 'dl_pos_z', 10, 100).onChange(function (e) {
	let nextValue = parseInt(e)
	dirLight.position.set( controls.dl_pos_x, controls.dl_pos_y, nextValue );
});





model1Folder = gui.addFolder('modelApple')

model1Folder.add(controls, 'model1_pos_x', -10, 10 ,0.1).onChange(function (e) {
	let nextValue = Number(e)
	modelApple.position.set( nextValue, controls.model1_pos_y, controls.model1_pos_z );
});

model1Folder.add(controls, 'model1_pos_y', -10, 10 ,0.1).onChange(function (e) {
	let nextValue = Number(e)
	modelApple.position.set( controls.model1_pos_x, nextValue, controls.model1_pos_z );
});

model1Folder.add(controls, 'model1_pos_z', -10, 10 ,0.1).onChange(function (e) {
	let nextValue = Number(e)
	modelApple.position.set( controls.model1_pos_x, controls.model1_pos_y, nextValue );
});



gui.add(controls, 'debug').onChange(function (e) {
		cameraHelper.visible = e;
});

gui.add(controls, 'castShadow').onChange(function (e) {
		directionalLight.castShadow = e;
});

gui.add(controls, 'target', ['Plane', 'Sphere', 'Cube']).onChange(function (e) {
		console.log(e);
		switch (e) {
				case "Plane":
						directionalLight.target = plane;
						break;
				case "Sphere":
						directionalLight.target = sphere;
						break;
				case "Cube":
						directionalLight.target = cube;
						break;
		}

});

cameraFolder.open()
spotLightFolder.open()
dirLightFolder.open()
model1Folder.open()


//バーテックスシェーダ
const vertexShader =`
 
    //精度の指定
    precision mediump float;
 
    //modelViewMatrixの宣言
    uniform mat4 modelViewMatrix;
 
    //projectionMatrixの宣言
    uniform mat4 projectionMatrix;
 
    //positionの宣言
    attribute vec3 position;
 
    //uvの宣言
    attribute vec2 uv;
 
    varying vec2 vUv;
 
    void main(){
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
 
        //フラグメントシェーダにuvを転送
        vUv = uv;
    }
`;
 
//フラグメントシェーダ
const fragmentShader =`
 
    //精度の指定
    precision mediump float;
 
    //timeを取得
    uniform float time;
 
    //vUvを取得
    varying vec2 vUv;
 
    void main(){
 
        //uv座標系で、オブジェクトの中心に原点を設定
        vec2 fuv = -1.0 + 2.0 * vUv;
 
        //uv座標系を使用して描画色を設定
        float r = abs(sin(fuv.s * fuv.t + time / 5.0));
        float g = abs(sin(fuv.s * fuv.t + time / 4.0));
        float b = abs(sin(fuv.s * fuv.t + time / 3.0));
 
        gl_FragColor = vec4(r,g,b,1.0);
    }
`;

//timeを設定
const uniforms = {
    time:{type:'f',value:1.0}
};


	import * as THREE from '../build/three.module.js';

	import Stats from './jsm/libs/stats.module.js';

	import { OrbitControls } from './jsm/controls/OrbitControls.js';
	import { ShadowMapViewer } from './jsm/utils/ShadowMapViewer.js';
	import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';

	let camera, scene, renderer, clock, stats;
	let dirLight, spotLight;
	let torusKnot, cube;
	let dirLightShadowMapViewer, spotLightShadowMapViewer;
	let modelApple
	let wall2

	// wall
	let material2;

	init();
	animate();


	function init() {

		initScene();
		initShadowMapViewers();
		initMisc();

		document.body.appendChild( renderer.domElement );
		window.addEventListener( 'resize', onWindowResize, false );

	}

	function initScene() {

		// シーン
		scene = new THREE.Scene();

		// カメラ
		camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
		camera.position.set( 0, 15, 35 );



		// Lights

		scene.add( new THREE.AmbientLight( 0x404040 ) );

		spotLight = new THREE.SpotLight( 0xffffff );
		spotLight.name = 'Spot Light';
		spotLight.angle = Math.PI / 5;
		spotLight.penumbra = 0.3;
		spotLight.position.set( 10, 10, 5 );
		spotLight.castShadow = true;
		spotLight.shadow.camera.near = 8;
		spotLight.shadow.camera.far = 30;
		spotLight.shadow.mapSize.width = 1024;
		spotLight.shadow.mapSize.height = 1024;
		scene.add( spotLight );

		scene.add( new THREE.CameraHelper( spotLight.shadow.camera ) );

		dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
		dirLight.name = 'Dir. Light';
		dirLight.position.set( 0, 10, 0 );
		dirLight.castShadow = true;
		dirLight.shadow.camera.near = 1;
		dirLight.shadow.camera.far = 10;
		dirLight.shadow.camera.right = 15;
		dirLight.shadow.camera.left = -15;
		dirLight.shadow.camera.top	= 15;
		dirLight.shadow.camera.bottom = - 15;
		dirLight.shadow.mapSize.width = 1024;
		dirLight.shadow.mapSize.height = 1024;
		scene.add( dirLight );

		scene.add( new THREE.CameraHelper( dirLight.shadow.camera ) );

		// Geometry
		let geometry = new THREE.TorusKnotBufferGeometry( 25, 8, 75, 20 );
		let material = new THREE.MeshPhongMaterial( {
			color: 0xff0010,
			shininess: 150,
			specular: 0x222222
		} );

		torusKnot = new THREE.Mesh( geometry, material );
		torusKnot.scale.multiplyScalar( 1 / 18 );
		torusKnot.position.y = 3;
		torusKnot.castShadow = true;
		torusKnot.receiveShadow = true;
		scene.add( torusKnot );

		geometry = new THREE.BoxBufferGeometry( 3, 3, 3 );
		cube = new THREE.Mesh( geometry, material );
		cube.position.set( 8, 3, 8 );
		cube.castShadow = true;
		cube.receiveShadow = true;
		scene.add( cube );

		/*
		geometry = new THREE.BoxBufferGeometry( 10, 0.15, 10 );
		material = new THREE.MeshPhongMaterial( {
			color: 0xa0adaf,
			shininess: 150, //150
			specular: 0x111111
		} );
		*/

		let textureLoader = new THREE.TextureLoader();
		let texture = null
		let nmTexture = null	

		// ground
		texture = textureLoader.load('../otherresources/plywood_1k_png/plywood_diff_1k.png');
		//texture = textureLoader.load('textures/01/FloorsCheckerboard_S_Diffuse.jpg');
		geometry = new THREE.BoxBufferGeometry( 30, 0.1, 30 );
		material = new THREE.MeshLambertMaterial( {
			color: 0xa0adaf
		} );
		const ground = new THREE.Mesh( geometry, material );
		material.map = texture;
		ground.castShadow = false;
		ground.receiveShadow = true;
		scene.add( ground );

		
		// wall 	
		let geometry2 = new THREE.BoxGeometry( 30, 15, 1 );
		material2 = new THREE.MeshBasicMaterial( /*{color: 0x11aa90}*/ );
		nmTexture = texture = textureLoader.load('../otherresources/leather_white_1k_png/leather_white_ao_1k.png');
		textureLoader.load('../otherresources/leather_white_1k_png/leather_white_nor_1k.png')
		material2.map = texture;
		material2.normalMap = nmTexture;
		material2.needsUpdate = true;

		const wall1 = new THREE.Mesh( geometry2, material2 );
		wall1.position.z = -15;
		wall1.position.y = 5;
		scene.add( wall1 );
		
		/*
		texture = textureLoader.load('../otherresources/leather_white_1k_png/leather_white_ao_1k.png');
		const geometry3 = new THREE.BoxGeometry( -1, 15, 30 );
		const material3 = new THREE.MeshBasicMaterial( {color: 0xa0ffff} );
		material3.map = texture;
		wall2 = new THREE.Mesh( geometry3, material3 );
		wall2.position.x = -15;
		wall2.position.y = 5;
		scene.add( wall2 );
		*/

		//RawShaderMaterial
		const shaderMaterial = new THREE.RawShaderMaterial({
				uniforms:uniforms,
				vertexShader:vertexShader,
				fragmentShader:fragmentShader,
		});

		const geometry3 = new THREE.BoxGeometry( -1, 15, 30 );		
		wall2 = new THREE.Mesh( geometry3, shaderMaterial );
		wall2.position.x = -15;
		wall2.position.y = 5;
		scene.add( wall2 );



		// モデル
		const　gltfLoader = new GLTFLoader();
		gltfLoader.load('../otherresources/apple.glb',function(data){
				const gltf = data;
				modelApple = gltf.scene;
				modelApple.scale.set(30.0, 30.0, 30.0);
				modelApple.position.set(1, 0, 4);
				modelApple.rotation.y = THREE.Math.DEG2RAD * -45;

				modelApple.traverse((object) => { //モデルの構成要素をforEach的に走査
        	if(object.isMesh) { //その構成要素がメッシュだったら
	    			//object.material.trasparent = true;
	    			//object.material.opacity = 0.5;
	    			object.material.castShadow = true;
	    			object.material.receiveShadow = true;					
					}
    		});

				scene.add(modelApple);
		});
			
		//読み込んだシーンが暗いので、明るくする
		//renderer.outputEncoding = THREE.GammaEncoding;

		let ah = new THREE.AxesHelper()
		scene.add(ah);

	}

	function initShadowMapViewers() {

		dirLightShadowMapViewer = new ShadowMapViewer( dirLight );
		spotLightShadowMapViewer = new ShadowMapViewer( spotLight );
		resizeShadowMapViewers();

	}

	function initMisc() {

		renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.shadowMap.enabled = true;
		renderer.shadowMap.type = THREE.BasicShadowMap;

		// Mouse control
		const controls = new OrbitControls( camera, renderer.domElement );
		controls.target.set( 0, 2, 0 );
		controls.update();

		clock = new THREE.Clock();

		stats = new Stats();
		document.body.appendChild( stats.dom );

	}

	function resizeShadowMapViewers() {

		const size = window.innerWidth * 0.15;

		 dirLightShadowMapViewer.position.x = 10;
		 dirLightShadowMapViewer.position.y = 10;
		 dirLightShadowMapViewer.size.width = size;
		 dirLightShadowMapViewer.size.height = size;
		 dirLightShadowMapViewer.update(); //Required when setting position or size directly

		spotLightShadowMapViewer.size.set( size, size );
		spotLightShadowMapViewer.position.set( size + 20, 10 );
		spotLightShadowMapViewer.update();	//NOT required because .set updates automatically

	}

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

		resizeShadowMapViewers();
			dirLightShadowMapViewer.updateForWindowResize();
		spotLightShadowMapViewer.updateForWindowResize();

	}

	function animate() {

		requestAnimationFrame( animate );

    step++; 
    //timeを更新
    wall2.material.uniforms.time.value = step / 60.0 * 5;

		render();
		stats.update();

	}

	function renderScene() {

		renderer.render( scene, camera );

	}

	function renderShadowMapViewers() {

		dirLightShadowMapViewer.render( renderer );
		spotLightShadowMapViewer.render( renderer );

	}

	function render() {

		const delta = clock.getDelta();

		renderScene();
		renderShadowMapViewers();

		torusKnot.rotation.x += 0.25 * delta;
		torusKnot.rotation.y += 2 * delta;
		torusKnot.rotation.z += 1 * delta;

		cube.rotation.x += 0.25 * delta;
		cube.rotation.y += 2 * delta;
		cube.rotation.z += 1 * delta;

	}

		</script>
	</body>
</html>
